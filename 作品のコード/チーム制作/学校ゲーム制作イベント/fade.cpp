//=============================================================================
//
// フェードの処理 [fade.cpp]
// Author : 佐藤瞭平
//
//=============================================================================
#include"fade.h"
#include"renderer.h"
#include"texture.h"
#include"bg.h"

//=============================================================================
// 静的メンバ関数の宣言
//=============================================================================
LPDIRECT3DTEXTURE9 CFade::m_pTexture = NULL;
CFade::FADE CFade::m_Fade = CFade::FADE_NONE;
D3DXCOLOR CFade::m_col = D3DXCOLOR(0.0f, 0.0f, 0.0f, 0.0f);
CManager::MODE CFade::m_ModeNext = CManager::MODE_TITLE;
CBg * CFade::m_pBg = NULL;

//=============================================================================
// フェードのコンストラクタ
//=============================================================================
CFade::CFade(PRIORITY Priority) : CScene2D(PRIORITY_FADE)
{
}

//=============================================================================
// フェードのデストラクタ
//=============================================================================
CFade::~CFade()
{

}
//=============================================================================
//　ポリゴンのテクスチャの設定
//=============================================================================
void CFade::BindTextuer(int nTex)
{
	m_pTexture = CManager::GetTexture()->GetTex(nTex);
}

//=============================================================================
// フェードの生成処理
//=============================================================================
CFade *CFade::Create(D3DXVECTOR3 pos, D3DXVECTOR2 Size, CManager::MODE mode)
{
	CFade* pFade;

	pFade = new CFade;

	if (pFade != NULL)
	{
		pFade->Init(pos, Size);
		pFade->SetFade(mode);		
	}
	return pFade;

}

//=============================================================================
// フェードの初期化処理
//=============================================================================
HRESULT CFade::Init(D3DXVECTOR3 pos, D3DXVECTOR2 Size)
{
	m_Fade = FADE_IN;
	m_col = D3DXCOLOR(0.0f, 0.0f, 0.0f, 0.0f);

	CScene2D::Init(pos,Size);
	CScene2D::Bindtexture(1);
	return S_OK;
}


//=============================================================================
// フェードの終了処理
//=============================================================================
void CFade::Uninit(void)
{
	CScene2D::Uninit();
}


//=============================================================================
// フェードの更新処理
//=============================================================================
void CFade::Update(void)
{
	// フェードの状態が何もしてない状態じゃなかったら
	if (m_Fade != FADE_NONE)
	{
		// フェードの状態がフェードイン状態だったら
		if (m_Fade == FADE_IN)
		{
			m_col.a -= 0.03f;

			if (m_col.a <= 0.00f)
			{
				m_col.a = 0.00f;

				// 何もしてない状態にする
				m_Fade = FADE_NONE;
			}
		}
		// フェードの状態がフェードアウト状態だったら
		else if (m_Fade == FADE_OUT)
		{
			m_col.a += 0.05f;

			if (m_col.a >= 1.00f)
			{
				m_col.a = 1.00f;

				// フェードイン状態にする
				m_Fade = FADE_IN;

				//モードの設定処理
				CManager::SetMode(m_ModeNext);
			}
		}		
		//色の設定処理
		CScene2D::SetColor(m_col);
	}
	//CScene2D::Update();
}

//=============================================================================
// フェードの描画処理
//=============================================================================
void CFade::Draw(void)
{
	CScene2D::Draw();
}

//=============================================================================
// フェードの配置処理
//=============================================================================
void CFade::SetFade(CManager::MODE modeNext)
{
	m_Fade = FADE_OUT;

	m_ModeNext = modeNext;

	m_col = D3DXCOLOR(0.0f, 0.0f, 0.0f, 0.0f);
}